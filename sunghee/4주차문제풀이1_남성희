

# 1,2,3 더하기
# Dynamic Programming
N = int(input())
def sol(n):
    if n == 1:
        return 1
    elif n == 2:
        return 2
    elif n == 3:
        return 4
    else:
        return sol(n-1) + sol(n-2) + sol(n-3)

for i in range(N):
    n = int(input())
    print(sol(n))

# 왜 n-1 + n-2 + n-3 이 되는 수열이 될까?
# 2:  1 + 1
# 3:  1 + 2
# 4 : 1 + 3 + 3
# 5 : 1 + 4 + 6 + 4

#수이어쓰기1 - 자세한설명은 ppt참고
import sys

input = sys.stdin.readline

n = int(input())
n = str(n)  # 120

answer = 0
for i in range(len(n) - 1):  # range(2), i=0,1
    answer += 9 * (i + 1) * 10 ** i   # answer = 9 + 9*2*10 = 189 , 99일때 189

answer += (int(n) - (10 ** (len(n) - 1)) + 1) * len(n)  #  (120 - 100 + 1 ) * 3 = 63
 
print(answer) # 252



#모든수열

n = int(input())  # 사용자로부터 n의 값을 입력받습니다. 여기서는 n에 3이 저장
temp = []  # 현재까지 생성된 순열을 저장할 리스트입니다.

def dfs():
    if len(temp) == n:  # temp 리스트에 n개의 숫자가 들어있으면 모든 순열이 생성된 것입니다.
        print(*temp)  # temp 리스트의 모든 요소를 공백으로 구분하여 출력합니다.
        return
    
    for i in range(1, n + 1):  # 1부터 n까지의 숫자에 대해서 반복합니다.
        if i not in temp:  # 숫자 i가 temp 리스트에 없으면 아직 사용되지 않은 숫자입니다.
            temp.append(i)  # temp 리스트에 숫자 i를 추가합니다.
            dfs()  # 재귀적으로 dfs 함수를 호출하여 다음 숫자를 선택합니다.
            temp.pop()  # 백트래킹을 수행하기 위해 마지막으로 추가한 숫자를 제거합니다.

dfs()  # dfs 함수를 호출하여 순열을 생성합니다.


# N 과 M

N, M = map(int, input().split())   # 3, 1
numbers = [int(x) for x in input().split()]  # 4, 5, 2

numbers.sort()  # 2, 4, 5

def backtracking(depth):
    if depth == M: # 깊이가 1일때
        print(' '.join(map(str,box))) # box 리스트가 [2, 4]이면 "2 4"를 출력
        return

    for i in range(N):  # N = 3 
        if numbers[i] in box: 
            continue
        box.append(numbers[i])   # numbers 리스트의 i번째 요소(일단 0)를 box 리스트에 추가
        backtracking(depth + 1)  # 깊이를 1 증가시켜 재귀적으로 backtracking 함수를 호
        box.pop()  # 백트래킹 수행

box = []
backtracking(0)

