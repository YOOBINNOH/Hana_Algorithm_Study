# 9095_1, 2, 3 더하기.py

# 풀이) DP 문제로 푸는 것임. dp를 초기화 할 떄 처음 dp=[0]*(n+1)로 해서 런타임에러가 발생했음. 
#       유빈님께 질문해보니 (n+3)까지 해야지 dp[3]=4라는 기본 값이 들어갈 수 있던 것임.
#       어차피 문제 내에서 n이 11부터 작다고 했기 때문에 [0] *12 라고 해도 됨.
#       어떻게 풀지 몰라 참고해서 푼 문제임

import sys

input = sys.stdin.readline
ip = int(input())


def add(n):
    dp = [0] * (n + 3)  # 이 부분이 중요한 듯..
    # 기본값
    dp[1] = 1
    dp[2] = 2
    dp[3] = 4

    if n < 4:
        return dp[n]

    for i in range(4, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]

    return dp[n]


for i in range(ip):
    k = int(input())
    print(add(k))




-------------------------------------------------------------------------------------------------
# 1748_수 이어쓰기 1.py

# 풀이) 처음에는 위와 같이 단순히 len()함수로 출력했음. 하지만 시간 초과 문제 발생.
#       코드 작성 전부터 시간 초과가 날 것이라고 알고 다른 방법으로 풀긴했어야 했음
#       문제가 너무 쉬워서 시간 초과 문제 발생할 것 같았는데 그래도 혹시 모르니까 일단 풀어본 것이기도 함.
#       계속 DP문제만 풀다보니 DP로 풀어야 하는 문제 아니까라고 생각이 들어 반복되는 부분을 찾아보려고 함.
#       겹치긴 했지만 이걸 DP로 어떻게 써야 하는 생각 때문에 계산식만 도출해내고 코드를 찾아봤지만 단순하게 계산식 도출해서 코드롤 작성하는 문제였던 것임..!
#       계산식은 미리 생각을 했어서 그런지 코드를 보면서 하나씩 해석하고 어떤 부분을 의미하는지 어떻게 풀어야 하는지 이해가 잘 됐음. 다음에 다시 풀어야 할 것 같긴 함.

# n = int(input())
# res = ""
# for i in range(1, n + 1):
#     res += str(i)

# print(len(res))

n = int(input())

k = len(str(n))  # 자리 수

count = 0
# 자리수 기반으로 개수 구함.
# 자리수 1개인 경우 숫자 1~9 다 더하면 9개
# (9-1+1)*1(자릿수)
# 자리수 2개인 경우 숫자 10~99 다 더하면 180개
# (99 - 10  + 1)*2(자릿수) = 180
for i in range(k - 1):
    count += 9 * 10**i * (i + 1)


# 자리수를 구하고 나머지 숫자를 구하고 출력
print(count + (n - 10 ** (k - 1) + 1) * k)

# 예를 들면 120을 구하라고 하면 2자리 수의 경우(count)에 추가적으로 count구할때처럼 계산하면 됨
# 120 => (180+9)에서 (120- 10 **2 +1)*3 = 21*3=63을 더해줘서
# 189+63 = 252






-------------------------------------------------------------------------------------------------
# 10974_모든 순열.py

# 풀이) 순열 하면 라이브러리가 가장 먼저 생각남. 그래서 prermutations 가져와서 사용함.
#       예전에 푼 경험도 있지만 해시에 들어있는 값들을 어떻게 빼냈었는지 기억이 나질 않아 참고하니 바로 기억남
#       * 연산자를 사용해서 쉽게 출력해서 해결함.


from itertools import permutations

n = int(input())
arr = list()
for i in range(1, n + 1):
    arr.append(i)

for j in permutations(arr):
    print(*j)

//////////////////////////////////
+) DFS로 풀 수 있는 문제로 DFS 풀이도 추가해 넣었다.
def dfs(depth):
    global ans

    if depth == n:
        print(*visited)
    else:
        for i in range(n):
            if i + 1 in visited:
                continue
            visited[depth] = i + 1
            dfs(depth + 1)
            visited[depth] = 0


n = int(input())
visited = [0] * n
dfs(0)



-------------------------------------------------------------------------------------------------
# 15654_N과 M (5).py

# 풀이) 이 문제도 순열 사용하는 문제였음.
#       sorted()로 for문으로 하면 정렬된 채로 나오는 문법을 알고 있어서 쉽게 해결함.
#       항상 라이브러리나 이렇게 문법으로 쉽게 풀면 시간초과가 나진 않을까 불안하긴 한달까?ㅎㅎ..


from itertools import permutations

n, m= map(int, input().split())

arr=list(map(int, input().split(" ")))

for i in sorted(permutations(arr, m)):
    print(*i)







